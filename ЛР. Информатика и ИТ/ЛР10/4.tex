\documentclass[a4paper,12pt]{article}
\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{geometry}
\usepackage{graphicx}
\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}
\newcommand{\jj}{\righthyphenmin=20 \justifying}
\usepackage{ragged2e}
\usepackage{indentfirst}
\parindent = 1cm
\addto\captionsrussian{\renewcommand{\refname}{Литература}}


\title{Ориентированные графы в реляционных базах данных}
\author{А.В. Маликов}
\date{Доклады ТУСУРа, № 2 (18), часть 2, декабрь 2008}

\begin{document}

\maketitle

\begin{abstract}
Рассматриваются и исследуются методы управления данными, представленными в виде орграфов. Исследуются вопросы эффективного моделирования орграфов в реляционных базах данных по критериям компактности хранения и высокой производительности манипулирования данными. Приводятся примеры запросов манипулирования данными орграфов.

\textbf{Ключевые слова:} реляционные базы данных, иерархические структуры, ориентированные графы, модификация иерархических данных, запросы манипулирования данными.
\end{abstract}

\section*{Моделирование ориентированных графов в реляционных базах данных}

Очень часто возникает необходимость в обработке больших массивов данных, представленных в виде иерархии. Если в качестве структурной абстракции при моделировании данных используется реляционная модель данных, то для моделирования иерархических структур должны использоваться специальные методы и подходы. В настоящее время не существует единого подхода к управлению иерархическими структурами данных. Наиболее исследованными, обладающими высокой эффективностью хранения и обработки данных в реляционных системах, являются методы управления деревьями. Основные направления в области моделирования деревьев в реляционных базах данных [1, 2]:

\begin{enumerate}
\item Использование отношения типа «родитель-потомок».
\item Использование типа данных XML.
\item Использование концепции «материализованного пути» (Materialized Path).
\end{enumerate}

Последнее направление является самым молодым и предполагает использование специального ключа, сопоставляемого каждой вершине дерева и содержащего в себе информацию обо всех вершинах по пути из корня дерева в саму вершину. Существует несколько подходов к вычислению материализованного пути. Множественная модель дерева [3] предполагает сопоставление каждой вершине дерева \( v \in V \), где \( V \) – множество вершин дерева, пары целочисленных значений (left0,right0), такой что, если \( u \in V \), \( u \to v \), то left0 < leftu, rightu < right0 . В [4] для реализации идеи материализованного пути каждой вершине дерева ставится в соответствие матрица размера \( 2 \times 2 \), содержащая целочисленные значения. Операциям модификации дерева ставятся в соответствие операции на матрицах. В [5] вводится новый тип данных на основе строкового типа данных для хранения значений материализованного пути как конкатенации символьных строк идентификаторов вершин на всех уровнях по пути из корня дерева в искомую вершину и расширяется набор функций для выполнения основных операций модификации дерева и извлечения данных. Похожий подход использован корпорацией Microsoft при создании в версии СУБД SQL Server 2008 нового типа данных HierarchyId [1, 2], являющегося расширением двоичных данных переменной длины.

Очень часто в реляционных системах возникает необходимость в моделировании иерархий данных, описываемых в виде ориентированных графов. Возможны две модификации описанных ранее методов. Так как в общем случае число вершин и дуг орграфа различно, то, в отличие от деревьев, необходимо использовать не одно реляционное отношение, а два – отдельно для хранения данных о вершинах и о характере связей между вершинами. Пусть мощность множества вершин орграфа равна \( n \), а множества дуг – \( m \), тогда использование концепции типа «родитель – потомок» предполагает создание реляционного отношения с вершинами мощностью \( n \) и отношения с дугами мощностью \( m \), содержащего пару атрибутов {IDparent,IDchild}, являющихся внешними ключами к первичному ключу отношения с вершинами орграфа. По всей видимости, данный подход предполагает наиболее компактное хранение данных об орграфе и обладает низкими вычислительными затратами на операции модификации орграфа. Проблема такого подхода заключается в крайне низкой эффективности запросов выборки данных и, соответственно, низкой производительности решения вычислительных задач на графах.

Непосредственное использование концепции материализованного пути невозможно. Для этого необходимо без потери информации заменить орграф деревом. Возможны реализации нескольких алгоритмов такой замены, например алгоритм обхода ориентированной сети [6]. Реализация такого подхода возможна только для небольших орграфов, в противном случае это может привести к значительному росту мощности отношения с данными о дугах дерева замены, а длина ключа материализованного пути может превысить ограничения СУБД для индексных структур. Действительно, если в ключе материализованного пути зашифрована информация обо всех предках вершины, включая саму вершину, то длина ключа \( L \) некоторой вершины на уровне \( l \) ориентированной сети равна

\[
L = \frac{a^l - 1}{a - 1} \cdot \lceil \log_2 b \rceil,
\]

где \( a > 1 \) – среднее число родителей вершин орграфа; \( b \in (1, \infty) \) – среднее число детей вершин орграфа; \( \lceil \cdot \rceil \) – функция, возвращающая минимальное целочисленное значение, большее аргумента; \( \lceil \log_2 b \rceil \) – длина фрагмента ключа для кодирования одной вершины на пути из корня дерева. Вообще значение длины фрагмента ключа кодирования определяется способом формирования ключа материализованного пути. Здесь использован самый оптимистичный способ кодирования, при котором для всякого родителя порядковый номер вершины-потомка кодируется битовой строкой переменной длины.

Приблизительная оценка длины ключа может быть вычислена по формуле

\[
L \leq l a^{l-1} \cdot \lceil \log_2 b \rceil.
\]

\section*{Методы повышения эффективности моделирования ориентированных графов в реляционных базах данных}

Обе описанные концепции можно обобщить, что позволит использовать достоинства каждой из них. Концепция типа «родитель – потомок» моделирует в реляционных таблицах бинарное отношение непосредственной достижимости на множестве вершин орграфа. Рефлексивно-транзитивным замыканием отношения непосредственной достижимости является отношение достижимости на орграфе. Данное отношение рефлексивно, транзитивно, антисимметрично и может быть представлено квадратной матрицей достижимости. Для реализации матрицы достижимости в реляционной системе создается две таблицы: в первой хранятся данные о вершинах, во второй – данные о достижимости между вершинами в виде пар (предок, потомок). Назовем данную концепцию типа «предки – потомки».

Таблица с данными о вершинах:

\begin{verbatim}
CREATE TABLE HierarchyObject
(ID int NOT NULL primary key,        - идентификатор вершины,
name varchar(50),                    - наименование вершины,
level int)                           - уровень вершины в ориентированной сети.
\end{verbatim}

Таблица с данными о достижимости между вершинами:

\begin{verbatim}
CREATE TABLE HierarchyLink
(IDancestor int NOT NULL,             - идентификатор вершины предка,
IDdescendant int NOT NULL)            - идентификатор вершины потомка.
\end{verbatim}

Атрибуты HierarchyLink.IDancestor и HierarchyLink.IDdescendant являются внешними ключами по отношению к атрибуту HierarchyObject.ID. В большинстве запросов к таблице HierarchyLink будет накладываться фильтр по атрибуту IDancestor и/или IDdescendant, поэтому для повышения производительности таких запросов по каждому из атрибутов строится отдельный некластерный индекс типа B-дерево, в котором листовые узлы будут ссылаться на конкретные значения данных. По атрибуту с более низкой селективностью рекомендуется построить кластерный индекс, что позволит в запросах на выборку данных считывать меньшее число страниц памяти, вследствие упорядочивания записей таблицы на диске.

Предложенный подход позволяет моделировать материализованный путь в более привычном для реляционных систем виде: в виде конечного множества кортежей. На рис. 1 показано сравнение методов кодирования и хранения дерева с использованием концепции типа «предки – потомки» и материализованного пути.

Таблица HierarchyLink построена на основе матрицы достижимости вершин дерева.

Оценим мощности отношений HierarchyObject и HierarchyLink. Мощность HierarchyObject равна числу вершин орграфа \( n \). Мощность \( H \) отношения HierarchyLink сопоставима с числом ячеек матрицы достижимости вершин орграфа:

\includegraphics{рисунок1.png}

\centering{\textbf{Матрица достижимости вершин дерева}}

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
вершины & 1 & 2 & 3 & 4 & 5 & 6 \\
\hline
1 & 1 &   &   &   &   &   \\
\hline
2 & 1 & 1 &   &   &   &   \\
\hline
3 & 1 &   & 1 &   &   &   \\
\hline
4 & 1 & 1 &   & 1 &   &   \\
\hline
5 & 1 & 1 &   &   & 1 &   \\
\hline
6 & 1 &   & 1 &   &   & 1 \\
\hline
\end{tabular}
\end{center}

\justifying{Матрица достижимости антисимметрична, следовательно, мощность отношения HierarchyLink может быть оценена как площадь прямоугольного треугольника с ячейками под главной диагональю матрицы достижимости: \( H \leq \frac{n^2 + n}{2} \). Полученная оценка достаточно грубая, так как заполненность описываемого треугольника признаками наличия пути между парами вершин может быть произвольной и зависит от характера связей между вершинами. Всякая вершина уровня \( l \) ориентированной сети имеет \( A = (a^0 + a^1 + a^2 + \ldots + a^{l-1}) \leq l a^{l-1} \) достижимых вершин. Если \( a = 1 \), то ориентированная сеть является деревом и число достижимых вершин равно \( A = l \). Если \( a \in (1, \infty) \), то сумма ряда равна \( A = \frac{a^{l} - 1}{a - 1} < n \). Если ориентированная сеть состоит из \( l \) уровней, то мощность отношения HierarchyLink можно оценить по формуле \( H \leq \frac{a^{l} - 1}{a - 1} \cdot n \leq l a^{l-1} n \). Для дерева справедливо \( a = 1 \), \( H \leq l \cdot n \).}

\section*{Манипулирование данными ориентированных графов}

Рассмотрим несколько примеров, демонстрирующих особенности формирования запросов к таблицам HierarchyObject и HierarchyLink.

Задача 1: найти общих предков вершин @ID1, @ID2, @ID3. Запрос на Transact SQL имеет вид:

\begin{verbatim}
SELECT h13.*
FROM HierarchyLink h11, HierarchyLink h12, HierarchyLink h13
WHERE h11.IDdescendant=@ID1 and
h12.IDdescendant=@ID2 and
h13.IDdescendant=@ID3 and
h11.IDancestor=h12.IDancestor and
h12.IDancestor=h13.IDancestor
\end{verbatim}

Задача 2: найти общих потомков вершин @ID1, @ID2, не являющихся потомками вершины @ID3.

\begin{verbatim}
SELECT h13.*
FROM HierarchyLink h11, HierarchyLink h12, HierarchyLink h13
WHERE h11.IDancestor=@ID1 and
h12.IDancestor=@ID2 and
h13.IDancestor=@ID3 and
h11.IDdescendant=h12.IDdescendant and
h12.IDdescendant<>h13.IDdescendant
\end{verbatim}

\justifying{Запросы на выборку данных из таблиц HierarchyObject и HierarchyLink обладают высокой производительностью, наглядностью и не предполагают изменения предикатов при изменении структуры орграфа.}

\justifying{Операции добавления, удаления и модификации дуг орграфа предполагают обработку подмножества записей таблицы HierarchyLink. Наиболее трудоемкой предполагается операция удаления дуги, при выполнении которой необходимо удалить записи о предках множества вершин-потомков. Если таблица HierarchyLink содержит только пару атрибутов (IDancestor, IDdescendant), то на основе содержащихся в них данных невозможно гарантированно определить, какие записи подлежат удалению. Данное ограничение обусловлено возможностью существования в орграфе альтернативных путей между парами вершин. Существуют, как минимум, два способа решения данной проблемы. Во-первых, возможно дополнение таблицы HierarchyLink новыми атрибутами, отражающими характер связей между вершинами, например введение признака наличия дуги между вершинами. Тогда для выполнения операций удаления и модификации дуги необходимо выполнять рекурсивный поиск всех связанных вершин для определения их подмножества, которое будет удалено в запросе. Такой подход не может считаться удачным, так как снижает производительность запросов удаления, модификации дуг и значительно загружает аппаратные ресурсы сервера базы данных. Во-вторых, возможна модификация без потери информации исходного орграфа к орграфу, не содержащему альтернативных путей между парами вершин. Проведение такой модификации возможно с использованием специальных алгоритмов, реализованных в нормализованных на основе операций выборки и соединения базах данных [7]. Рассмотрим особенности запросов добавления, удаления и модификации дуг орграфа, в котором отсутствуют альтернативные пути между парами вершин. Исходной информацией для запросов являются значения двух переменных (@IDparent, @IDchild), идентифицирующих конкретную дугу орграфа.}

Задача 3: добавить в орграф дугу (@IDparent, @IDchild).

\begin{verbatim}
INSERT HierarchyLink
SELECT b.IDancestor, a.IDdescendant
FROM HierarchyLink a, HierarchyLink b
WHERE a.IDancestor=@IDchild and b.IDdescendant=@IDparent
\end{verbatim}

Предложение SELECT формирует все возможные пары из потомков вершины @IDchild, включая ее саму, и предков вершины @IDparent, включая ее саму.

Задача 4: удалить из орграфа дугу (@IDparent, @IDchild).

\begin{verbatim}
DELETE HierarchyLink
FROM HierarchyLink a, HierarchyLink b
WHERE a.IDancestor=@IDchild and b.IDdescendant=@IDparent and
HierarchyLink.IDancestor=b.IDancestor and
HierarchyLink.IDdescendant=a.IDdescendant
\end{verbatim}

Задача 5: заменить в орграфе дугу (@IDparentOld, @IDchild) дугой (@IDparentNew, @IDchild).

\begin{verbatim}
DELETE HierarchyLink
FROM HierarchyLink a, HierarchyLink b
WHERE a.IDancestor=@IDchild and b.IDdescendant=@IDparentOld and
HierarchyLink.IDancestor=b.IDancestor and
HierarchyLink.IDdescendant=a.IDdescendant

INSERT HierarchyLink
SELECT b.IDancestor, a.IDdescendant
FROM HierarchyLink a, HierarchyLink b
WHERE a.IDancestor=@IDchild and b.IDdescendant=@IDparentNew
\end{verbatim}

\section*{Выводы}

\justifying{Наиболее популярные методы моделирования деревьев в реляционных базах данных: отношение типа «родитель – потомок», тип данных XML, концепция материализованного пути. Обладая высокой эффективностью управления данными, представленными в виде деревьев, они не позволяют эффективно управлять данными, представленными в виде орграфов. Для моделирования орграфов в реляционных базах данных предложенные методы должны быть модифицированы. Перспективным направлением представляется отображение в реляционной системе матрицы достижимости, т.е. моделирование бинарного отношения достижимости между вершинами орграфа. Для управления множеством вершин создается отдельное реляционное отношение. Второе реляционное отношение используется для хранения отношения достижимости между парами вершин. Предложенный подход позволяет реализовать концепцию материализованного пути в более привычном для реляционных систем виде: как конечное множество кортежей реляционного отношения. По атрибутам последнего отношения строятся индексы типа сбалансированного дерева, что позволяет добиться высокой производительности запросов выборки данных. Мощности отношений оцениваются полиномиальными функциями от мощности множества вершин исходного орграфа. Представлены запросы поддержания орграфа в актуальном состоянии.}


\begin{thebibliography}{9}
\bibitem{sql1}
SQL Server 2008 Books Online (May 2008), Using hierarchyid Data Types (Database Engine) [Электронный ресурс]. – Режим доступа: \texttt{http://technet.microsoft.com/en-us/library/bb677173(SQL.100).aspx}, свободный.

\bibitem{sql2}
SQL Server 2008 Books Online (May 2008), hierarchyid (Transact-SQL). [Электронный ресурс]. – Режим доступа: \texttt{http://technet.microsoft.com/en-us/library/bb677290(SQL.100).aspx}, свободный.

\bibitem{celko}
Celko J., Trees in SQL [Электронный ресурс]. – Режим доступа свободный. \texttt{http://www.intelligententerprise.com/001020/celko.shtml}

\bibitem{tropashko}
Tropashko V. Nested Intervals Tree Encoding with Continued Fractions [Электронный ресурс]. – Режим доступа: \texttt{http://arxiv.org/abs/cs.DB/0402051}, свободный.

\bibitem{roy}
Roy J., Using the Node Type to Solve Problems with Hierarchies in DB2® Universal Database [Электронный ресурс]. – Режим доступа свободный. \texttt{http://www.106.ibm.com/developerworks/db2/library/technetic/e/0302roy/0302roy.html}

\bibitem{malikov1}
Malikov A. Mathematical model for storing and effective processing of directed graphs in semistructured data management systems / A. Malikov, Y. Gulevskiy, D. Parkhomenko // ARTIFICIAL INTELLIGENCE, KNOWLEDGE INGINEERING and DATA BASES (AIKED '08) (UK, Cambridge, University of Cambridge). – 2008. – P. 541–548.

\bibitem{malikov2}
Маликов А. Проектирование реляционных баз данных на основе операций выборки и соединения. Исследование их свойств. – Ставрополь: СевКавГТУ, 2002. – 245 c.
\end{thebibliography}

\noindent
\textbf{Маликов Андрей Валерьевич}\\
Д-р техн. наук, доцент, проф. кафедры информационных систем и технологий Северо-Кавказского государственного технического университета\\
Тел.: (8652) 56-39-10\\
Эл. почта: malikov@ncsu.ru\\
\\
A.V. Malikov\\
\textbf{Directed graphs in relational databases}\\
\\
Methods for managing data, which are represented as directed graphs, are considered and studied. Problems of compact storage and high data management performance of directed graphs in relational data bases are analyzed. Power evaluation of relations keeping directed graphs data is given. Examples
of data management queries are shown.\\
\textbf{Key words:} relational databases, hierarchical structures, directed graphs, hierarchical data modification,
database queries

\end{document}